
# 이와 비슷하게 생각을 했다.
# m / k = 몫  -- 나머지
#
# k * 몫이 가장 큰수의 개수라고 판단하였다. 그리고 그 나머지가 두번째로 큰 수의 개수라고 생각을 하였다.
# 여기까지만 하면 맞는거 같은데 괜히 나머지가 3보다 크면 앞에 과정을 반복하고 아님 종료한다라는 논리로 이어져서 문제를 못 푼 것 같다.
# 애초에 나머지가 3보다 크게 나올 수 없는 구조라서 이렇게 쓸 필요가 없었다.
#
# 여튼 답안지에서는 예를 들어 [2,4,5,4,6]을 정렬해서 [2,4,4,5,6]으로 정렬한 뒤 더해지는 수의 패턴을 보면 [6,6,6,5]가 반복된다.
# 그렇다면 반복되는 수열의 길이는 어떻게 될까?
# 바로 (k + 1)로 위의 예시에서는 4가 된다. 따라서 M을 (k+1)로 나눈 몫이 수열이 반복되는 횟수가 된다. 다시 여기서 k를 곱해주면 가장 큰 수가
# 등장하는 횟수가 된다. 이때 M이 (k + 1)로 나누어떨어지지 않는 경우도 고려해야 한다. 그럴 ㅓ때는 M을 (k+1)로 나눈 나머지 만큼 가장 큰수가 추가로 더해지므로
# 이를 고려해주여야 한다.
# 식으로 나타내면  int(M/(k+1)) * k + m % (k+1)


n,m,k = map(int, input().split())
data = list (map(int, input().split()))


data.sort() # 입력받은 수들 정렬하기
first = data[n - 1] # 가장 큰 수
second = data[n - 2] # 두 번째로 큰수

# 가장 큰 수가 더해지는 횟수 계산
count = int(m / (k + 1)) * k
count += m % (k+1)

result = 0
result += (count) * first
result += (m - count) * second

print(result)
